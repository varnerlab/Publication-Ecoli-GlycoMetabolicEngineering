function [solution] = SA(Sinitial,Tinitial,Alpha,Minitial,Maxtime,pMutation,pRandom,maxKO,DFIN,costDriver)
% ------------------------------------------------------------------------------------- 
% SA.m
% Simulated Annealing (SA)
% New states are generated by random swapping of knockout genes. Also, point-wise
% mutation is applied with probability pMutation, and a completely new mutant
% may be generated with probability pRandom.
% Sinitial = initial knockout mutant, 1 X nGENE binary vector
% Tinitial = initial temperature
% Alpha = cooling rate
% Minitial = time until next parameter update
% Maxtime = maximum number of iterations
% pMutation = probability of mutation
% pRandom = probability of new mutant
% maxKO = maximum number of knockouts allowed
% DFIN = DataFile struct containing metabolic system parameters
% costDriver = pointer to cost function
% solution is a struct containing simulation results with fields:
% solution.objective - Maxtime X 4 matrix
% 	column 1 --> iteration number
% 	column 2 --> current cost
% 	column 3 --> best cost so far
% 	column 4 --> biomass flux of best solution so far
% solution.best.iteration = iteration of best solution so far
% solution.best.state = knockout indices of best solution so far
% solution.model = string corresponding to network
% solution.substrate = growth medium substrates
% solution.maxKO = max number of knockouts allowed
% solution.target = index of target flux
% solution.biomass = index of biomass flux
% solution.txn = Boolean value of txn network
% ------------------------------------------------------------------------------------- 

% Simulation parameters -
solution.model = DFIN.MODEL;
solution.substrate = DFIN.SUBSTRATE;
solution.maxKO = maxKO;
solution.target = DFIN.FLUX_TARGET;
solution.biomass = DFIN.FLUX_BIOMASS;
solution.txn = DFIN.TXN;

% Set initial parameters -
currT = Tinitial;
currS = Sinitial;
solution.best.iteration(1) = 1;
solution.best.state{1} = find(currS);
idxUpdate = 1;
tempChromosome = 1-currS;
[currCost,tempBio,tempGlyco] = feval(costDriver,tempChromosome,DFIN);
%disp(['Initial Cost: ',num2str(currCost)]);
bestCost = currCost;
bestBio = tempBio;
Time = 0;

% Initialize output -
% Zeroth iteration
solution.objective = [1,currCost,bestCost,bestBio];

% Iteration counter -
iter = 1;

% Search until max iteration exceeded -
while (Time < Maxtime)
	
	% New Counter -
	newM = Minitial;
	
	while (newM > 0)

		% Update iteration -
		iter = iter + 1;
		%disp(['Iteration: ',num2str(iter)]);

		% Get new state and cost -
		newS = neighborhood(currS,DFIN);
		newS = mutation(newS,pMutation,maxKO,DFIN);
		newS = random(newS,pRandom,maxKO,DFIN,costDriver);
		tempChromosome = 1-newS;
		[newCost,tempBio,tempGlyco] = feval(costDriver,tempChromosome,DFIN);
		%disp([newCost,tempBio,tempGlyco])
		% Calculate change in cost -
		deltaCost = newCost - currCost;
		
		% Selection criterion -
		if (deltaCost < 0)
			% Downhill move -
			currS = newS;
			currCost = newCost;
			% Keep track of best state and cost -
			if (newCost < bestCost)
				idxUpdate = idxUpdate + 1;
				solution.best.iteration(idxUpdate) = iter;
				solution.best.state{idxUpdate} = find(newS);
				bestCost = newCost;
				bestBio = tempBio;
			end
			%disp(['	- Move Downhill, Current Cost: ',num2str(currCost),', Best Cost: ',num2str(bestCost)]);
		elseif (rand < exp(-deltaCost/currT))
			% Uphill move -
			currS = newS;
			currCost = newCost;
			%if (currCost==0)
				%disp(['	- Move Zero, Current Cost: ',num2str(currCost),', Best Cost: ',num2str(bestCost)]);
			%else
				%disp(['	- Move Uphill, Current Cost: ',num2str(currCost),', Best Cost: ',num2str(bestCost)]);
			%end
		end
		
		% Update counter -
		newM = newM - 1;
		
		% Update outputs -
		solution.objective = [solution.objective; iter,currCost,bestCost,bestBio];
		
	end
	
	% Update time and temperature -
	Time = Time + Minitial;
	currT = Alpha*currT;

	% Save periodically -
	save -mat ./sim_results/solution.mat solution;

end

return;
